// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"context"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer/types"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/transport/viewer"
	"github.com/google/uuid"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"time"
)

type loggerDevTools struct {
	next multiplayer.DevTools
}

func loggerMiddlewareDevTools() MiddlewareDevTools {
	return func(next multiplayer.DevTools) multiplayer.DevTools {
		return &loggerDevTools{next: next}
	}
}

func (m loggerDevTools) CreateGame(ctx context.Context, token string, game types.Game) (id uuid.UUID, err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "createGame").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsCreateGame{
					Game:  game,
					Token: token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsCreateGame{Id: id}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call createGame")
			return
		}
		logger.Info().Func(logHandle).Msg("call createGame")
	}(time.Now())
	return m.next.CreateGame(ctx, token, game)
}

func (m loggerDevTools) GameAddOwner(ctx context.Context, token string, gameID uuid.UUID, userID uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "gameAddOwner").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsGameAddOwner{
					GameID: gameID,
					Token:  token,
					UserID: userID,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsGameAddOwner{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call gameAddOwner")
			return
		}
		logger.Info().Func(logHandle).Msg("call gameAddOwner")
	}(time.Now())
	return m.next.GameAddOwner(ctx, token, gameID, userID)
}

func (m loggerDevTools) GameRemoveUser(ctx context.Context, token string, gameID uuid.UUID, userID uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "gameRemoveUser").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsGameRemoveUser{
					GameID: gameID,
					Token:  token,
					UserID: userID,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsGameRemoveUser{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call gameRemoveUser")
			return
		}
		logger.Info().Func(logHandle).Msg("call gameRemoveUser")
	}(time.Now())
	return m.next.GameRemoveUser(ctx, token, gameID, userID)
}

func (m loggerDevTools) UpdateGame(ctx context.Context, token string, gameID uuid.UUID, newGame types.Game) (id uuid.UUID, err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "updateGame").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsUpdateGame{
					GameID:  gameID,
					NewGame: newGame,
					Token:   token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsUpdateGame{Id: id}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call updateGame")
			return
		}
		logger.Info().Func(logHandle).Msg("call updateGame")
	}(time.Now())
	return m.next.UpdateGame(ctx, token, gameID, newGame)
}

func (m loggerDevTools) DeleteGame(ctx context.Context, token string, gameID uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "deleteGame").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsDeleteGame{
					GameID: gameID,
					Token:  token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsDeleteGame{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call deleteGame")
			return
		}
		logger.Info().Func(logHandle).Msg("call deleteGame")
	}(time.Now())
	return m.next.DeleteGame(ctx, token, gameID)
}

func (m loggerDevTools) GetMyGames(ctx context.Context, token string) (games []types.Game, err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "getMyGames").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request":  viewer.Sprintf("%+v", requestDevToolsGetMyGames{Token: token}),
				"response": viewer.Sprintf("%+v", responseDevToolsGetMyGames{Games: games}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getMyGames")
			return
		}
		logger.Info().Func(logHandle).Msg("call getMyGames")
	}(time.Now())
	return m.next.GetMyGames(ctx, token)
}

func (m loggerDevTools) GetGameByGameID(ctx context.Context, token string, gameID uuid.UUID) (game types.Game, err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "getGameByGameID").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsGetGameByGameID{
					GameID: gameID,
					Token:  token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsGetGameByGameID{Game: game}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getGameByGameID")
			return
		}
		logger.Info().Func(logHandle).Msg("call getGameByGameID")
	}(time.Now())
	return m.next.GetGameByGameID(ctx, token, gameID)
}

func (m loggerDevTools) TurnOnServerInGame(ctx context.Context, token string, serverID uuid.UUID, gameId uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "turnOnServerInGame").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsTurnOnServerInGame{
					GameId:   gameId,
					ServerID: serverID,
					Token:    token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsTurnOnServerInGame{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call turnOnServerInGame")
			return
		}
		logger.Info().Func(logHandle).Msg("call turnOnServerInGame")
	}(time.Now())
	return m.next.TurnOnServerInGame(ctx, token, serverID, gameId)
}

func (m loggerDevTools) TurnOffServerInGame(ctx context.Context, token string, serverID uuid.UUID, gameId uuid.UUID) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "DevTools").Str("method", "turnOffServerInGame").Logger()
	defer func(begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"request": viewer.Sprintf("%+v", requestDevToolsTurnOffServerInGame{
					GameId:   gameId,
					ServerID: serverID,
					Token:    token,
				}),
				"response": viewer.Sprintf("%+v", responseDevToolsTurnOffServerInGame{}),
			}
			ev.Fields(fields).Str("took", time.Since(begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call turnOffServerInGame")
			return
		}
		logger.Info().Func(logHandle).Msg("call turnOffServerInGame")
	}(time.Now())
	return m.next.TurnOffServerInGame(ctx, token, serverID, gameId)
}
