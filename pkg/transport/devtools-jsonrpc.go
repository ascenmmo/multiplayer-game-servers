// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"encoding/json"
	"strings"
	"sync"

	"github.com/ascenmmo/multiplayer-game-servers/pkg/transport/context"
	"github.com/gofiber/fiber/v2"
	"github.com/rs/zerolog/log"
)

func (http *httpDevTools) serveCreateGame(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "creategame", http.createGame)
}
func (http *httpDevTools) createGame(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsCreateGame
	var response responseDevToolsCreateGame

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.createGame").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "creategame",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	response.Id, err = http.svc.CreateGame(methodCtx, request.Token, request.Game)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveGameAddOwner(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "gameaddowner", http.gameAddOwner)
}
func (http *httpDevTools) gameAddOwner(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsGameAddOwner
	var response responseDevToolsGameAddOwner

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.gameAddOwner").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "gameaddowner",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	err = http.svc.GameAddOwner(methodCtx, request.Token, request.GameID, request.UserID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveGameRemoveOwner(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "gameremoveowner", http.gameRemoveOwner)
}
func (http *httpDevTools) gameRemoveOwner(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsGameRemoveOwner
	var response responseDevToolsGameRemoveOwner

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.gameRemoveOwner").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "gameremoveowner",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	err = http.svc.GameRemoveOwner(methodCtx, request.Token, request.GameID, request.UserID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveUpdateGame(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "updategame", http.updateGame)
}
func (http *httpDevTools) updateGame(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsUpdateGame
	var response responseDevToolsUpdateGame

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.updateGame").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "updategame",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	response.Id, err = http.svc.UpdateGame(methodCtx, request.Token, request.GameID, request.NewGame)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveDeleteGame(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "deletegame", http.deleteGame)
}
func (http *httpDevTools) deleteGame(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsDeleteGame
	var response responseDevToolsDeleteGame

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.deleteGame").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "deletegame",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	err = http.svc.DeleteGame(methodCtx, request.Token, request.GameID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveGetMyGames(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "getmygames", http.getMyGames)
}
func (http *httpDevTools) getMyGames(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsGetMyGames
	var response responseDevToolsGetMyGames

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.getMyGames").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "getmygames",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	response.Games, err = http.svc.GetMyGames(methodCtx, request.Token)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveGetGameByGameID(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "getgamebygameid", http.getGameByGameID)
}
func (http *httpDevTools) getGameByGameID(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsGetGameByGameID
	var response responseDevToolsGetGameByGameID

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.getGameByGameID").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "getgamebygameid",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	response.Game, err = http.svc.GetGameByGameID(methodCtx, request.Token, request.GameID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveTurnOnServerInGame(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "turnonserveringame", http.turnOnServerInGame)
}
func (http *httpDevTools) turnOnServerInGame(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsTurnOnServerInGame
	var response responseDevToolsTurnOnServerInGame

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.turnOnServerInGame").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "turnonserveringame",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	err = http.svc.TurnOnServerInGame(methodCtx, request.Token, request.ServerID, request.GameId)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) serveTurnOffServerInGame(ctx *fiber.Ctx) (err error) {
	return http._serveMethod(ctx, "turnoffserveringame", http.turnOffServerInGame)
}
func (http *httpDevTools) turnOffServerInGame(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsTurnOffServerInGame
	var response responseDevToolsTurnOffServerInGame

	methodCtx := ctx.UserContext()
	methodCtx = log.Ctx(methodCtx).With().Str("method", "devTools.turnOffServerInGame").Logger().WithContext(methodCtx)

	defer func() {
		ctx.SetUserContext(context.WithCtx(methodCtx, MethodCallMeta{

			Err:      err,
			Method:   "turnoffserveringame",
			Request:  &request,
			Response: &response,
			Service:  "devtools",
		}))
	}()
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	err = http.svc.TurnOffServerInGame(methodCtx, request.Token, request.ServerID, request.GameId)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}

	return
}
func (http *httpDevTools) _serveMethod(ctx *fiber.Ctx, methodName string, methodHandler methodJsonRPC) (err error) {

	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
	}
	var request baseJsonRPC
	var response *baseJsonRPC
	if err = json.Unmarshal(ctx.Body(), &request); err != nil {
		return sendResponse(ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
	}
	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	if method != "" && method != methodName {
		return sendResponse(ctx, makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method "+methodNameOrigin, nil))
	}
	response = methodHandler(ctx, request)
	if response != nil {
		return sendResponse(ctx, response)
	}
	return
}
func (http *httpDevTools) doBatch(ctx *fiber.Ctx, requests []baseJsonRPC) (responses jsonrpcResponses) {

	if len(requests) > http.maxBatchSize {
		responses.append(makeErrorResponseJsonRPC(nil, invalidRequestError, "batch size exceeded", nil))
		return
	}
	if strings.EqualFold(ctx.Get("X-Sync-On"), "true") {
		for _, request := range requests {
			response := http.doSingleBatch(ctx, request)
			if request.ID != nil {
				responses.append(response)
			}
		}
		return
	}
	var wg sync.WaitGroup
	batchSize := http.maxParallelBatch
	if len(requests) < batchSize {
		batchSize = len(requests)
	}
	callCh := make(chan baseJsonRPC, batchSize)
	responses = make(jsonrpcResponses, 0, len(requests))
	for i := 0; i < batchSize; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for request := range callCh {
				response := http.doSingleBatch(ctx, request)
				if request.ID != nil {
					responses.append(response)
				}
			}
		}()
	}
	for idx := range requests {
		callCh <- requests[idx]
	}
	close(callCh)
	wg.Wait()
	return
}
func (http *httpDevTools) serveBatch(ctx *fiber.Ctx) (err error) {

	var single bool
	var requests []baseJsonRPC
	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
		return
	}
	if err = json.Unmarshal(ctx.Body(), &requests); err != nil {
		var request baseJsonRPC
		if err = json.Unmarshal(ctx.Body(), &request); err != nil {
			return sendResponse(ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
		}
		single = true
		requests = append(requests, request)
	}
	if single {
		return sendResponse(ctx, http.doSingleBatch(ctx, requests[0]))
	}
	return sendResponse(ctx, http.doBatch(ctx, requests))
}
func (http *httpDevTools) doSingleBatch(ctx *fiber.Ctx, request baseJsonRPC) (response *baseJsonRPC) {

	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	switch method {
	case "creategame":
		return http.createGame(ctx, request)
	case "gameaddowner":
		return http.gameAddOwner(ctx, request)
	case "gameremoveowner":
		return http.gameRemoveOwner(ctx, request)
	case "updategame":
		return http.updateGame(ctx, request)
	case "deletegame":
		return http.deleteGame(ctx, request)
	case "getmygames":
		return http.getMyGames(ctx, request)
	case "getgamebygameid":
		return http.getGameByGameID(ctx, request)
	case "turnonserveringame":
		return http.turnOnServerInGame(ctx, request)
	case "turnoffserveringame":
		return http.turnOffServerInGame(ctx, request)
	default:
		return makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method '"+methodNameOrigin+"'", nil)
	}
}
