// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"encoding/json"
	"github.com/gofiber/fiber/v2"
	otg "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/ext"
	"strings"
	"sync"
)

const (
	defaultMaxBatchSize     = 100
	defaultMaxParallelBatch = 10
	// Version defines the version of the JSON RPC implementation
	Version = "2.0"
	// contentTypeJson defines the content type to be served
	contentTypeJson = "application/json"
	// ParseError defines invalid JSON was received by the server
	// An error occurred on the server while parsing the JSON text
	parseError = -32700
	// InvalidRequestError defines the JSON sent is not a valid Request object
	invalidRequestError = -32600
	// MethodNotFoundError defines the method does not exist / is not available
	methodNotFoundError = -32601
	// InvalidParamsError defines invalid method parameter(s)
	invalidParamsError = -32602
	// InternalError defines a server error
	internalError = -32603
)

type idJsonRPC = json.RawMessage

type baseJsonRPC struct {
	ID      idJsonRPC       `json:"id"`
	Version string          `json:"jsonrpc"`
	Method  string          `json:"method,omitempty"`
	Error   *errorJsonRPC   `json:"error,omitempty"`
	Params  json.RawMessage `json:"params,omitempty"`
	Result  json.RawMessage `json:"result,omitempty"`
}

type errorJsonRPC struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (err errorJsonRPC) Error() string {
	return err.Message
}

type jsonrpcResponses []*baseJsonRPC

func (responses *jsonrpcResponses) append(response *baseJsonRPC) {
	if response == nil {
		return
	}
	if response.ID != nil {
		*responses = append(*responses, response)
	}
}
func (srv *Server) serveBatch(ctx *fiber.Ctx) (err error) {

	var single bool
	var requests []baseJsonRPC
	batchSpan := otg.SpanFromContext(ctx.UserContext())
	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ext.Error.Set(batchSpan, true)
		batchSpan.SetTag("msg", "only POST method supported")
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
		return
	}
	if err = json.Unmarshal(ctx.Body(), &requests); err != nil {
		var request baseJsonRPC
		if err = json.Unmarshal(ctx.Body(), &request); err != nil {
			ext.Error.Set(batchSpan, true)
			batchSpan.SetTag("msg", "request body could not be decoded: "+err.Error())
			return sendResponse(ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
		}
		single = true
		requests = append(requests, request)
	}
	if single {
		return sendResponse(ctx, srv.doSingleBatch(ctx, requests[0]))
	}
	return sendResponse(ctx, srv.doBatch(ctx, requests))
}
func (srv *Server) doBatch(ctx *fiber.Ctx, requests []baseJsonRPC) (responses jsonrpcResponses) {

	if len(requests) > srv.maxBatchSize {
		responses.append(makeErrorResponseJsonRPC(nil, invalidRequestError, "batch size exceeded", nil))
		return
	}
	if strings.EqualFold(ctx.Get("X-Sync-On"), "true") {
		for _, request := range requests {
			response := srv.doSingleBatch(ctx, request)
			if request.ID != nil {
				responses.append(response)
			}
		}
		return
	}
	var wg sync.WaitGroup
	batchSize := srv.maxParallelBatch
	if len(requests) < batchSize {
		batchSize = len(requests)
	}
	callCh := make(chan baseJsonRPC, batchSize)
	responses = make(jsonrpcResponses, 0, len(requests))
	for i := 0; i < batchSize; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for request := range callCh {
				response := srv.doSingleBatch(ctx, request)
				if request.ID != nil {
					responses.append(response)
				}
			}
		}()
	}
	for idx := range requests {
		callCh <- requests[idx]
	}
	close(callCh)
	wg.Wait()
	return
}
func (srv *Server) doSingleBatch(ctx *fiber.Ctx, request baseJsonRPC) (response *baseJsonRPC) {

	methodCtx := ctx.UserContext()
	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	batchSpan := otg.SpanFromContext(methodCtx)
	span := otg.StartSpan(request.Method, otg.ChildOf(batchSpan.Context()))
	defer span.Finish()
	methodCtx = otg.ContextWithSpan(methodCtx, span)
	switch method {
	case "devtools.creategame":
		return srv.httpDevTools.createGame(ctx, request)
	case "devtools.gameaddowner":
		return srv.httpDevTools.gameAddOwner(ctx, request)
	case "devtools.gameremoveowner":
		return srv.httpDevTools.gameRemoveOwner(ctx, request)
	case "devtools.updategame":
		return srv.httpDevTools.updateGame(ctx, request)
	case "devtools.deletegame":
		return srv.httpDevTools.deleteGame(ctx, request)
	case "devtools.getmygames":
		return srv.httpDevTools.getMyGames(ctx, request)
	case "devtools.getgamebygameid":
		return srv.httpDevTools.getGameByGameID(ctx, request)
	case "devtools.turnonserveringame":
		return srv.httpDevTools.turnOnServerInGame(ctx, request)
	case "devtools.turnoffserveringame":
		return srv.httpDevTools.turnOffServerInGame(ctx, request)
	case "devtoolsclient.signup":
		return srv.httpDevToolsClient.signUp(ctx, request)
	case "devtoolsclient.signin":
		return srv.httpDevToolsClient.signIn(ctx, request)
	case "devtoolsclient.refreshtoken":
		return srv.httpDevToolsClient.refreshToken(ctx, request)
	case "devtoolsclient.getclient":
		return srv.httpDevToolsClient.getClient(ctx, request)
	case "devtoolsclient.updateclient":
		return srv.httpDevToolsClient.updateClient(ctx, request)
	case "devtoolsclient.getgamesaves":
		return srv.httpDevToolsClient.getGameSaves(ctx, request)
	case "devtoolsclient.setgamesaves":
		return srv.httpDevToolsClient.setGameSaves(ctx, request)
	case "devtoolsclient.deletegamesaves":
		return srv.httpDevToolsClient.deleteGameSaves(ctx, request)
	case "devtoolsconnections.createroom":
		return srv.httpDevToolsConnections.createRoom(ctx, request)
	case "devtoolsconnections.getroomsall":
		return srv.httpDevToolsConnections.getRoomsAll(ctx, request)
	case "devtoolsconnections.joinroombyid":
		return srv.httpDevToolsConnections.joinRoomByID(ctx, request)
	case "devtoolsconnections.removeroombyid":
		return srv.httpDevToolsConnections.removeRoomByID(ctx, request)
	case "devtoolsconnections.getroomsconnectionurls":
		return srv.httpDevToolsConnections.getRoomsConnectionUrls(ctx, request)
	case "devtoolsgameconfigs.createorupdateconfig":
		return srv.httpDevToolsGameConfigs.createOrUpdateConfig(ctx, request)
	case "devtoolsgameconfigs.getgameconfig":
		return srv.httpDevToolsGameConfigs.getGameConfig(ctx, request)
	case "devtoolsgameconfigs.getgameresultconfigpreview":
		return srv.httpDevToolsGameConfigs.getGameResultConfigPreview(ctx, request)
	case "devtoolsserver.addserver":
		return srv.httpDevToolsServer.addServer(ctx, request)
	case "devtoolsserver.getservers":
		return srv.httpDevToolsServer.getServers(ctx, request)
	case "devtoolsserver.deleteservers":
		return srv.httpDevToolsServer.deleteServers(ctx, request)
	case "developers.signup":
		return srv.httpDevelopers.signUp(ctx, request)
	case "developers.signin":
		return srv.httpDevelopers.signIn(ctx, request)
	case "developers.refreshtoken":
		return srv.httpDevelopers.refreshToken(ctx, request)
	case "developers.getdeveloper":
		return srv.httpDevelopers.getDeveloper(ctx, request)
	case "developers.updatedeveloper":
		return srv.httpDevelopers.updateDeveloper(ctx, request)
	default:
		ext.Error.Set(span, true)
		span.SetTag("msg", "invalid method '"+methodNameOrigin+"'")
		return makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method '"+methodNameOrigin+"'", nil)
	}
}

type methodJsonRPC func(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC)

func makeErrorResponseJsonRPC(id idJsonRPC, code int, msg string, data interface{}) *baseJsonRPC {

	if id == nil {
		return nil
	}

	return &baseJsonRPC{
		Error: &errorJsonRPC{
			Code:    code,
			Data:    data,
			Message: msg,
		},
		ID:      id,
		Version: Version,
	}
}
