// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"encoding/json"
	"github.com/gofiber/fiber/v2"
	otg "github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/ext"
	"strings"
	"sync"
)

func (http *httpDevToolsConnections) serveCreateRoom(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "createroom", http.createRoom)
}
func (http *httpDevToolsConnections) createRoom(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsCreateRoom

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "createRoom")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsCreateRoom
	response.NewToken, err = http.svc.CreateRoom(methodCtx, request.Token, request.Name)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveGetRoomsAll(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "getroomsall", http.getRoomsAll)
}
func (http *httpDevToolsConnections) getRoomsAll(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsGetRoomsAll

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "getRoomsAll")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsGetRoomsAll
	response.Rooms, err = http.svc.GetRoomsAll(methodCtx, request.Token)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveJoinRoomByID(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "joinroombyid", http.joinRoomByID)
}
func (http *httpDevToolsConnections) joinRoomByID(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsJoinRoomByID

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "joinRoomByID")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsJoinRoomByID
	response.NewToken, err = http.svc.JoinRoomByID(methodCtx, request.Token, request.RoomID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveJoinRoomByRoomCode(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "joinroombyroomcode", http.joinRoomByRoomCode)
}
func (http *httpDevToolsConnections) joinRoomByRoomCode(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsJoinRoomByRoomCode

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "joinRoomByRoomCode")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsJoinRoomByRoomCode
	response.NewToken, err = http.svc.JoinRoomByRoomCode(methodCtx, request.Token, request.RoomCode)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveGetMyRoom(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "getmyroom", http.getMyRoom)
}
func (http *httpDevToolsConnections) getMyRoom(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsGetMyRoom

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "getMyRoom")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsGetMyRoom
	response.Room, err = http.svc.GetMyRoom(methodCtx, request.Token)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveLeaveRoom(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "leaveroom", http.leaveRoom)
}
func (http *httpDevToolsConnections) leaveRoom(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsLeaveRoom

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "leaveRoom")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsLeaveRoom
	err = http.svc.LeaveRoom(methodCtx, request.Token, request.RoomID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveRemoveRoomByID(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "removeroombyid", http.removeRoomByID)
}
func (http *httpDevToolsConnections) removeRoomByID(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsRemoveRoomByID

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "removeRoomByID")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsRemoveRoomByID
	err = http.svc.RemoveRoomByID(methodCtx, request.Token, request.RoomID)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveGetRoomsConnectionUrls(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "getroomsconnectionurls", http.getRoomsConnectionUrls)
}
func (http *httpDevToolsConnections) getRoomsConnectionUrls(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {

	var err error
	var request requestDevToolsConnectionsGetRoomsConnectionUrls

	methodCtx := ctx.UserContext()
	span := otg.SpanFromContext(methodCtx)
	span.SetTag("method", "getRoomsConnectionUrls")

	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			ext.Error.Set(span, true)
			span.SetTag("msg", "request body could not be decoded: "+err.Error())
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		ext.Error.Set(span, true)
		span.SetTag("msg", "incorrect protocol version: "+requestBase.Version)
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}

	if _token := string(ctx.Request().Header.Peek("Token")); _token != "" {
		var token string
		token = _token
		request.Token = token
	}

	var response responseDevToolsConnectionsGetRoomsConnectionUrls
	response.ConnectionsServer, err = http.svc.GetRoomsConnectionUrls(methodCtx, request.Token)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		ext.Error.Set(span, true)
		span.SetTag("msg", err)
		span.SetTag("errData", toString(err))
		code := internalError
		if errCoder, ok := err.(withErrorCode); ok {
			code = errCoder.Code()
		}
		return makeErrorResponseJsonRPC(requestBase.ID, code, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "response body could not be encoded: "+err.Error())
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpDevToolsConnections) serveMethod(ctx *fiber.Ctx, methodName string, methodHandler methodJsonRPC) (err error) {

	span := otg.SpanFromContext(ctx.UserContext())
	span.SetTag("method", methodName)

	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ext.Error.Set(span, true)
		span.SetTag("msg", "only POST method supported")
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
	}
	var request baseJsonRPC
	var response *baseJsonRPC
	if err = json.Unmarshal(ctx.Body(), &request); err != nil {
		ext.Error.Set(span, true)
		span.SetTag("msg", "request body could not be decoded: "+err.Error())
		return sendResponse(ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
	}
	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	if method != "" && method != methodName {
		ext.Error.Set(span, true)
		span.SetTag("msg", "invalid method "+methodNameOrigin)
		return sendResponse(ctx, makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method "+methodNameOrigin, nil))
	}
	response = methodHandler(ctx, request)
	if response != nil {
		return sendResponse(ctx, response)
	}
	return
}
func (http *httpDevToolsConnections) doBatch(ctx *fiber.Ctx, requests []baseJsonRPC) (responses jsonrpcResponses) {

	if len(requests) > http.maxBatchSize {
		responses.append(makeErrorResponseJsonRPC(nil, invalidRequestError, "batch size exceeded", nil))
		return
	}
	if strings.EqualFold(ctx.Get("X-Sync-On"), "true") {
		for _, request := range requests {
			response := http.doSingleBatch(ctx, request)
			if request.ID != nil {
				responses.append(response)
			}
		}
		return
	}
	var wg sync.WaitGroup
	batchSize := http.maxParallelBatch
	if len(requests) < batchSize {
		batchSize = len(requests)
	}
	callCh := make(chan baseJsonRPC, batchSize)
	responses = make(jsonrpcResponses, 0, len(requests))
	for i := 0; i < batchSize; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for request := range callCh {
				response := http.doSingleBatch(ctx, request)
				if request.ID != nil {
					responses.append(response)
				}
			}
		}()
	}
	for idx := range requests {
		callCh <- requests[idx]
	}
	close(callCh)
	wg.Wait()
	return
}
func (http *httpDevToolsConnections) serveBatch(ctx *fiber.Ctx) (err error) {

	var single bool
	var requests []baseJsonRPC
	batchSpan := otg.SpanFromContext(ctx.UserContext())
	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ext.Error.Set(batchSpan, true)
		batchSpan.SetTag("msg", "only POST method supported")
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
		return
	}
	if err = json.Unmarshal(ctx.Body(), &requests); err != nil {
		var request baseJsonRPC
		if err = json.Unmarshal(ctx.Body(), &request); err != nil {
			ext.Error.Set(batchSpan, true)
			batchSpan.SetTag("msg", "request body could not be decoded: "+err.Error())
			return sendResponse(ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
		}
		single = true
		requests = append(requests, request)
	}
	if single {
		return sendResponse(ctx, http.doSingleBatch(ctx, requests[0]))
	}
	return sendResponse(ctx, http.doBatch(ctx, requests))
}
func (http *httpDevToolsConnections) doSingleBatch(ctx *fiber.Ctx, request baseJsonRPC) (response *baseJsonRPC) {

	methodContext := ctx.UserContext()
	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	batchSpan := otg.SpanFromContext(methodContext)
	span := otg.StartSpan(request.Method, otg.ChildOf(batchSpan.Context()))
	defer span.Finish()
	methodContext = otg.ContextWithSpan(ctx.UserContext(), span)
	switch method {
	case "createroom":
		return http.createRoom(ctx, request)
	case "getroomsall":
		return http.getRoomsAll(ctx, request)
	case "joinroombyid":
		return http.joinRoomByID(ctx, request)
	case "joinroombyroomcode":
		return http.joinRoomByRoomCode(ctx, request)
	case "getmyroom":
		return http.getMyRoom(ctx, request)
	case "leaveroom":
		return http.leaveRoom(ctx, request)
	case "removeroombyid":
		return http.removeRoomByID(ctx, request)
	case "getroomsconnectionurls":
		return http.getRoomsConnectionUrls(ctx, request)
	default:
		ext.Error.Set(span, true)
		span.SetTag("msg", "invalid method '"+methodNameOrigin+"'")
		return makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method '"+methodNameOrigin+"'", nil)
	}
}
