// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"context"
	"time"

	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer/types"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/transport/viewer"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type loggerDevelopers struct {
	next multiplayer.Developers
}

func loggerMiddlewareDevelopers() MiddlewareDevelopers {
	return func(next multiplayer.Developers) multiplayer.Developers {
		return &loggerDevelopers{next: next}
	}
}

func (m loggerDevelopers) SignUp(ctx context.Context, developer types.Developer) (token string, refresh string, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Developers").Str("method", "signUp").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":  "developers.signUp",
				"request": viewer.Sprintf("%+v", requestDevelopersSignUp{Developer: developer}),
				"response": viewer.Sprintf("%+v", responseDevelopersSignUp{
					Refresh: refresh,
					Token:   token,
				}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call signUp")
			return
		}
		logger.Info().Func(logHandle).Msg("call signUp")
	}(time.Now())
	return m.next.SignUp(ctx, developer)
}

func (m loggerDevelopers) SignIn(ctx context.Context, developer types.Developer) (token string, refresh string, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Developers").Str("method", "signIn").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":  "developers.signIn",
				"request": viewer.Sprintf("%+v", requestDevelopersSignIn{Developer: developer}),
				"response": viewer.Sprintf("%+v", responseDevelopersSignIn{
					Refresh: refresh,
					Token:   token,
				}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call signIn")
			return
		}
		logger.Info().Func(logHandle).Msg("call signIn")
	}(time.Now())
	return m.next.SignIn(ctx, developer)
}

func (m loggerDevelopers) RefreshToken(ctx context.Context, token string, refresh string) (newToken string, newRefresh string, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Developers").Str("method", "refreshToken").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "developers.refreshToken",
				"request": viewer.Sprintf("%+v", requestDevelopersRefreshToken{
					Refresh: refresh,
					Token:   token,
				}),
				"response": viewer.Sprintf("%+v", responseDevelopersRefreshToken{
					NewRefresh: newRefresh,
					NewToken:   newToken,
				}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call refreshToken")
			return
		}
		logger.Info().Func(logHandle).Msg("call refreshToken")
	}(time.Now())
	return m.next.RefreshToken(ctx, token, refresh)
}

func (m loggerDevelopers) GetDeveloper(ctx context.Context, token string) (developer types.Developer, err error) {
	logger := log.Ctx(ctx).With().Str("service", "Developers").Str("method", "getDeveloper").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method":   "developers.getDeveloper",
				"request":  viewer.Sprintf("%+v", requestDevelopersGetDeveloper{Token: token}),
				"response": viewer.Sprintf("%+v", responseDevelopersGetDeveloper{Developer: developer}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call getDeveloper")
			return
		}
		logger.Info().Func(logHandle).Msg("call getDeveloper")
	}(time.Now())
	return m.next.GetDeveloper(ctx, token)
}

func (m loggerDevelopers) UpdateDeveloper(ctx context.Context, token string, developer types.Developer) (err error) {
	logger := log.Ctx(ctx).With().Str("service", "Developers").Str("method", "updateDeveloper").Logger()
	defer func(_begin time.Time) {
		logHandle := func(ev *zerolog.Event) {
			fields := map[string]interface{}{
				"method": "developers.updateDeveloper",
				"request": viewer.Sprintf("%+v", requestDevelopersUpdateDeveloper{
					Developer: developer,
					Token:     token,
				}),
				"response": viewer.Sprintf("%+v", responseDevelopersUpdateDeveloper{}),
			}
			ev.Fields(fields).Str("took", time.Since(_begin).String())
		}
		if err != nil {
			logger.Error().Err(err).Func(logHandle).Msg("call updateDeveloper")
			return
		}
		logger.Info().Func(logHandle).Msg("call updateDeveloper")
	}(time.Now())
	return m.next.UpdateDeveloper(ctx, token, developer)
}
