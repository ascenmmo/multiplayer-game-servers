// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package multiplayer

import (
	"context"
	"fmt"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/hasher"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/jsonrpc"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer/types"
)

type ClientDevelopers struct {
	*ClientJsonRPC
}

type retDevelopersSignUp = func(token string, refresh string, err error)
type retDevelopersSignIn = func(token string, refresh string, err error)
type retDevelopersRefreshToken = func(newToken string, newRefresh string, err error)
type retDevelopersGetDeveloper = func(developer types.Developer, err error)
type retDevelopersUpdateDeveloper = func(err error)

func (cli *ClientDevelopers) SignUp(ctx context.Context, developer types.Developer) (token string, refresh string, err error) {

	request := requestDevelopersSignUp{Developer: developer}
	var response responseDevelopersSignUp
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "developers.signup", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevelopers != nil {
		fallbackCheck = cli.fallbackDevelopers.SignUp
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Token, response.Refresh, err
}

func (cli *ClientDevelopers) ReqSignUp(ctx context.Context, callback retDevelopersSignUp, developer types.Developer) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "developers.signup",
		Params:  requestDevelopersSignUp{Developer: developer},
	}}
	if callback != nil {
		var response responseDevelopersSignUp
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevelopers != nil {
				fallbackCheck = cli.fallbackDevelopers.SignUp
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Token, response.Refresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevelopers) SignIn(ctx context.Context, developer types.Developer) (token string, refresh string, err error) {

	request := requestDevelopersSignIn{Developer: developer}
	var response responseDevelopersSignIn
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "developers.signin", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevelopers != nil {
		fallbackCheck = cli.fallbackDevelopers.SignIn
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Token, response.Refresh, err
}

func (cli *ClientDevelopers) ReqSignIn(ctx context.Context, callback retDevelopersSignIn, developer types.Developer) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "developers.signin",
		Params:  requestDevelopersSignIn{Developer: developer},
	}}
	if callback != nil {
		var response responseDevelopersSignIn
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevelopers != nil {
				fallbackCheck = cli.fallbackDevelopers.SignIn
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Token, response.Refresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevelopers) RefreshToken(ctx context.Context, token string, refresh string) (newToken string, newRefresh string, err error) {

	request := requestDevelopersRefreshToken{
		Refresh: refresh,
		Token:   token,
	}
	var response responseDevelopersRefreshToken
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "developers.refreshtoken", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevelopers != nil {
		fallbackCheck = cli.fallbackDevelopers.RefreshToken
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.NewToken, response.NewRefresh, err
}

func (cli *ClientDevelopers) ReqRefreshToken(ctx context.Context, callback retDevelopersRefreshToken, token string, refresh string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "developers.refreshtoken",
		Params: requestDevelopersRefreshToken{
			Refresh: refresh,
			Token:   token,
		},
	}}
	if callback != nil {
		var response responseDevelopersRefreshToken
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevelopers != nil {
				fallbackCheck = cli.fallbackDevelopers.RefreshToken
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.NewToken, response.NewRefresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevelopers) GetDeveloper(ctx context.Context, token string) (developer types.Developer, err error) {

	request := requestDevelopersGetDeveloper{Token: token}
	var response responseDevelopersGetDeveloper
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "developers.getdeveloper", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevelopers != nil {
		fallbackCheck = cli.fallbackDevelopers.GetDeveloper
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Developer, err
}

func (cli *ClientDevelopers) ReqGetDeveloper(ctx context.Context, callback retDevelopersGetDeveloper, token string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "developers.getdeveloper",
		Params:  requestDevelopersGetDeveloper{Token: token},
	}}
	if callback != nil {
		var response responseDevelopersGetDeveloper
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevelopers != nil {
				fallbackCheck = cli.fallbackDevelopers.GetDeveloper
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Developer, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevelopers) UpdateDeveloper(ctx context.Context, token string, developer types.Developer) (err error) {

	request := requestDevelopersUpdateDeveloper{
		Developer: developer,
		Token:     token,
	}
	var response responseDevelopersUpdateDeveloper
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "developers.updatedeveloper", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevelopers != nil {
		fallbackCheck = cli.fallbackDevelopers.UpdateDeveloper
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevelopers) ReqUpdateDeveloper(ctx context.Context, callback retDevelopersUpdateDeveloper, token string, developer types.Developer) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "developers.updatedeveloper",
		Params: requestDevelopersUpdateDeveloper{
			Developer: developer,
			Token:     token,
		},
	}}
	if callback != nil {
		var response responseDevelopersUpdateDeveloper
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevelopers != nil {
				fallbackCheck = cli.fallbackDevelopers.UpdateDeveloper
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}
