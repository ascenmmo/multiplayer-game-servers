// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package multiplayer

import (
	"context"
	"fmt"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/hasher"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/jsonrpc"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer/types"
	"github.com/google/uuid"
)

type ClientDevTools struct {
	*ClientJsonRPC
}

type retDevToolsCreateGame = func(id uuid.UUID, err error)
type retDevToolsGameAddOwner = func(err error)
type retDevToolsGameRemoveOwner = func(err error)
type retDevToolsUpdateGame = func(id uuid.UUID, err error)
type retDevToolsDeleteGame = func(err error)
type retDevToolsGetMyGames = func(games []types.Game, err error)
type retDevToolsGetGameByGameID = func(game types.Game, err error)
type retDevToolsTurnOnServerInGame = func(err error)
type retDevToolsTurnOffServerInGame = func(err error)

func (cli *ClientDevTools) CreateGame(ctx context.Context, token string, game types.Game) (id uuid.UUID, err error) {

	request := requestDevToolsCreateGame{
		Game:  game,
		Token: token,
	}
	var response responseDevToolsCreateGame
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.creategame", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.CreateGame
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Id, err
}

func (cli *ClientDevTools) ReqCreateGame(ctx context.Context, callback retDevToolsCreateGame, token string, game types.Game) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.creategame",
		Params: requestDevToolsCreateGame{
			Game:  game,
			Token: token,
		},
	}}
	if callback != nil {
		var response responseDevToolsCreateGame
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.CreateGame
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Id, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) GameAddOwner(ctx context.Context, token string, gameID uuid.UUID, userID uuid.UUID) (err error) {

	request := requestDevToolsGameAddOwner{
		GameID: gameID,
		Token:  token,
		UserID: userID,
	}
	var response responseDevToolsGameAddOwner
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.gameaddowner", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.GameAddOwner
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevTools) ReqGameAddOwner(ctx context.Context, callback retDevToolsGameAddOwner, token string, gameID uuid.UUID, userID uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.gameaddowner",
		Params: requestDevToolsGameAddOwner{
			GameID: gameID,
			Token:  token,
			UserID: userID,
		},
	}}
	if callback != nil {
		var response responseDevToolsGameAddOwner
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.GameAddOwner
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) GameRemoveOwner(ctx context.Context, token string, gameID uuid.UUID, userID uuid.UUID) (err error) {

	request := requestDevToolsGameRemoveOwner{
		GameID: gameID,
		Token:  token,
		UserID: userID,
	}
	var response responseDevToolsGameRemoveOwner
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.gameremoveowner", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.GameRemoveOwner
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevTools) ReqGameRemoveOwner(ctx context.Context, callback retDevToolsGameRemoveOwner, token string, gameID uuid.UUID, userID uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.gameremoveowner",
		Params: requestDevToolsGameRemoveOwner{
			GameID: gameID,
			Token:  token,
			UserID: userID,
		},
	}}
	if callback != nil {
		var response responseDevToolsGameRemoveOwner
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.GameRemoveOwner
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) UpdateGame(ctx context.Context, token string, gameID uuid.UUID, newGame types.Game) (id uuid.UUID, err error) {

	request := requestDevToolsUpdateGame{
		GameID:  gameID,
		NewGame: newGame,
		Token:   token,
	}
	var response responseDevToolsUpdateGame
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.updategame", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.UpdateGame
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Id, err
}

func (cli *ClientDevTools) ReqUpdateGame(ctx context.Context, callback retDevToolsUpdateGame, token string, gameID uuid.UUID, newGame types.Game) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.updategame",
		Params: requestDevToolsUpdateGame{
			GameID:  gameID,
			NewGame: newGame,
			Token:   token,
		},
	}}
	if callback != nil {
		var response responseDevToolsUpdateGame
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.UpdateGame
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Id, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) DeleteGame(ctx context.Context, token string, gameID uuid.UUID) (err error) {

	request := requestDevToolsDeleteGame{
		GameID: gameID,
		Token:  token,
	}
	var response responseDevToolsDeleteGame
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.deletegame", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.DeleteGame
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevTools) ReqDeleteGame(ctx context.Context, callback retDevToolsDeleteGame, token string, gameID uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.deletegame",
		Params: requestDevToolsDeleteGame{
			GameID: gameID,
			Token:  token,
		},
	}}
	if callback != nil {
		var response responseDevToolsDeleteGame
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.DeleteGame
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) GetMyGames(ctx context.Context, token string) (games []types.Game, err error) {

	request := requestDevToolsGetMyGames{Token: token}
	var response responseDevToolsGetMyGames
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.getmygames", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.GetMyGames
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Games, err
}

func (cli *ClientDevTools) ReqGetMyGames(ctx context.Context, callback retDevToolsGetMyGames, token string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.getmygames",
		Params:  requestDevToolsGetMyGames{Token: token},
	}}
	if callback != nil {
		var response responseDevToolsGetMyGames
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.GetMyGames
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Games, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) GetGameByGameID(ctx context.Context, token string, gameID uuid.UUID) (game types.Game, err error) {

	request := requestDevToolsGetGameByGameID{
		GameID: gameID,
		Token:  token,
	}
	var response responseDevToolsGetGameByGameID
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.getgamebygameid", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.GetGameByGameID
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Game, err
}

func (cli *ClientDevTools) ReqGetGameByGameID(ctx context.Context, callback retDevToolsGetGameByGameID, token string, gameID uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.getgamebygameid",
		Params: requestDevToolsGetGameByGameID{
			GameID: gameID,
			Token:  token,
		},
	}}
	if callback != nil {
		var response responseDevToolsGetGameByGameID
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.GetGameByGameID
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Game, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) TurnOnServerInGame(ctx context.Context, token string, serverID uuid.UUID, gameId uuid.UUID) (err error) {

	request := requestDevToolsTurnOnServerInGame{
		GameId:   gameId,
		ServerID: serverID,
		Token:    token,
	}
	var response responseDevToolsTurnOnServerInGame
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.turnonserveringame", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.TurnOnServerInGame
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevTools) ReqTurnOnServerInGame(ctx context.Context, callback retDevToolsTurnOnServerInGame, token string, serverID uuid.UUID, gameId uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.turnonserveringame",
		Params: requestDevToolsTurnOnServerInGame{
			GameId:   gameId,
			ServerID: serverID,
			Token:    token,
		},
	}}
	if callback != nil {
		var response responseDevToolsTurnOnServerInGame
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.TurnOnServerInGame
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevTools) TurnOffServerInGame(ctx context.Context, token string, serverID uuid.UUID, gameId uuid.UUID) (err error) {

	request := requestDevToolsTurnOffServerInGame{
		GameId:   gameId,
		ServerID: serverID,
		Token:    token,
	}
	var response responseDevToolsTurnOffServerInGame
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtools.turnoffserveringame", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevTools != nil {
		fallbackCheck = cli.fallbackDevTools.TurnOffServerInGame
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevTools) ReqTurnOffServerInGame(ctx context.Context, callback retDevToolsTurnOffServerInGame, token string, serverID uuid.UUID, gameId uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtools.turnoffserveringame",
		Params: requestDevToolsTurnOffServerInGame{
			GameId:   gameId,
			ServerID: serverID,
			Token:    token,
		},
	}}
	if callback != nil {
		var response responseDevToolsTurnOffServerInGame
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevTools != nil {
				fallbackCheck = cli.fallbackDevTools.TurnOffServerInGame
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}
