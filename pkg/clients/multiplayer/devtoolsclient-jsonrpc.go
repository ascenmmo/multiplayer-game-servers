// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package multiplayer

import (
	"context"
	"fmt"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/hasher"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/clients/multiplayer/jsonrpc"
	"github.com/ascenmmo/multiplayer-game-servers/pkg/multiplayer/types"
	"github.com/google/uuid"
)

type ClientDevToolsClient struct {
	*ClientJsonRPC
}

type retDevToolsClientSignUp = func(token string, refresh string, err error)
type retDevToolsClientSignIn = func(token string, refresh string, err error)
type retDevToolsClientRefreshToken = func(newToken string, newRefresh string, err error)
type retDevToolsClientGetClient = func(client types.Client, err error)
type retDevToolsClientUpdateClient = func(err error)
type retDevToolsClientGetGameSaves = func(gameSaves types.GameSaves, err error)
type retDevToolsClientSetGameSaves = func(err error)
type retDevToolsClientDeleteGameSaves = func(err error)

func (cli *ClientDevToolsClient) SignUp(ctx context.Context, client types.Client) (token string, refresh string, err error) {

	request := requestDevToolsClientSignUp{Client: client}
	var response responseDevToolsClientSignUp
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.signup", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.SignUp
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Token, response.Refresh, err
}

func (cli *ClientDevToolsClient) ReqSignUp(ctx context.Context, callback retDevToolsClientSignUp, client types.Client) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.signup",
		Params:  requestDevToolsClientSignUp{Client: client},
	}}
	if callback != nil {
		var response responseDevToolsClientSignUp
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.SignUp
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Token, response.Refresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) SignIn(ctx context.Context, client types.Client) (token string, refresh string, err error) {

	request := requestDevToolsClientSignIn{Client: client}
	var response responseDevToolsClientSignIn
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.signin", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.SignIn
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Token, response.Refresh, err
}

func (cli *ClientDevToolsClient) ReqSignIn(ctx context.Context, callback retDevToolsClientSignIn, client types.Client) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.signin",
		Params:  requestDevToolsClientSignIn{Client: client},
	}}
	if callback != nil {
		var response responseDevToolsClientSignIn
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.SignIn
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Token, response.Refresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) RefreshToken(ctx context.Context, token string, refresh string) (newToken string, newRefresh string, err error) {

	request := requestDevToolsClientRefreshToken{
		Refresh: refresh,
		Token:   token,
	}
	var response responseDevToolsClientRefreshToken
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.refreshtoken", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.RefreshToken
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.NewToken, response.NewRefresh, err
}

func (cli *ClientDevToolsClient) ReqRefreshToken(ctx context.Context, callback retDevToolsClientRefreshToken, token string, refresh string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.refreshtoken",
		Params: requestDevToolsClientRefreshToken{
			Refresh: refresh,
			Token:   token,
		},
	}}
	if callback != nil {
		var response responseDevToolsClientRefreshToken
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.RefreshToken
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.NewToken, response.NewRefresh, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) GetClient(ctx context.Context, token string, gameID uuid.UUID) (client types.Client, err error) {

	request := requestDevToolsClientGetClient{
		GameID: gameID,
		Token:  token,
	}
	var response responseDevToolsClientGetClient
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.getclient", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.GetClient
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.Client, err
}

func (cli *ClientDevToolsClient) ReqGetClient(ctx context.Context, callback retDevToolsClientGetClient, token string, gameID uuid.UUID) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.getclient",
		Params: requestDevToolsClientGetClient{
			GameID: gameID,
			Token:  token,
		},
	}}
	if callback != nil {
		var response responseDevToolsClientGetClient
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.GetClient
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.Client, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) UpdateClient(ctx context.Context, token string, client types.Client) (err error) {

	request := requestDevToolsClientUpdateClient{
		Client: client,
		Token:  token,
	}
	var response responseDevToolsClientUpdateClient
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.updateclient", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.UpdateClient
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevToolsClient) ReqUpdateClient(ctx context.Context, callback retDevToolsClientUpdateClient, token string, client types.Client) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.updateclient",
		Params: requestDevToolsClientUpdateClient{
			Client: client,
			Token:  token,
		},
	}}
	if callback != nil {
		var response responseDevToolsClientUpdateClient
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.UpdateClient
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) GetGameSaves(ctx context.Context, token string) (gameSaves types.GameSaves, err error) {

	request := requestDevToolsClientGetGameSaves{Token: token}
	var response responseDevToolsClientGetGameSaves
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.getgamesaves", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.GetGameSaves
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return response.GameSaves, err
}

func (cli *ClientDevToolsClient) ReqGetGameSaves(ctx context.Context, callback retDevToolsClientGetGameSaves, token string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.getgamesaves",
		Params:  requestDevToolsClientGetGameSaves{Token: token},
	}}
	if callback != nil {
		var response responseDevToolsClientGetGameSaves
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.GetGameSaves
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(response.GameSaves, cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) SetGameSaves(ctx context.Context, token string, gameSaves types.GameSaves) (err error) {

	request := requestDevToolsClientSetGameSaves{
		GameSaves: gameSaves,
		Token:     token,
	}
	var response responseDevToolsClientSetGameSaves
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.setgamesaves", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.SetGameSaves
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevToolsClient) ReqSetGameSaves(ctx context.Context, callback retDevToolsClientSetGameSaves, token string, gameSaves types.GameSaves) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.setgamesaves",
		Params: requestDevToolsClientSetGameSaves{
			GameSaves: gameSaves,
			Token:     token,
		},
	}}
	if callback != nil {
		var response responseDevToolsClientSetGameSaves
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.SetGameSaves
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}

func (cli *ClientDevToolsClient) DeleteGameSaves(ctx context.Context, token string) (err error) {

	request := requestDevToolsClientDeleteGameSaves{Token: token}
	var response responseDevToolsClientDeleteGameSaves
	var rpcResponse *jsonrpc.ResponseRPC
	cacheKey, _ := hasher.Hash(request)
	rpcResponse, err = cli.rpc.Call(ctx, "devtoolsclient.deletegamesaves", request)
	var fallbackCheck func(error) bool
	if cli.fallbackDevToolsClient != nil {
		fallbackCheck = cli.fallbackDevToolsClient.DeleteGameSaves
	}
	if rpcResponse != nil && rpcResponse.Error != nil {
		if cli.errorDecoder != nil {
			err = cli.errorDecoder(rpcResponse.Error.Raw())
		} else {
			err = fmt.Errorf(rpcResponse.Error.Message)
		}
	}
	if err = cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response); err != nil {
		return
	}
	return err
}

func (cli *ClientDevToolsClient) ReqDeleteGameSaves(ctx context.Context, callback retDevToolsClientDeleteGameSaves, token string) (request RequestRPC) {

	request = RequestRPC{rpcRequest: &jsonrpc.RequestRPC{
		ID:      jsonrpc.NewID(),
		JSONRPC: jsonrpc.Version,
		Method:  "devtoolsclient.deletegamesaves",
		Params:  requestDevToolsClientDeleteGameSaves{Token: token},
	}}
	if callback != nil {
		var response responseDevToolsClientDeleteGameSaves
		request.retHandler = func(err error, rpcResponse *jsonrpc.ResponseRPC) {
			cacheKey, _ := hasher.Hash(request.rpcRequest.Params)
			var fallbackCheck func(error) bool
			if cli.fallbackDevToolsClient != nil {
				fallbackCheck = cli.fallbackDevToolsClient.DeleteGameSaves
			}
			if rpcResponse != nil && rpcResponse.Error != nil {
				if cli.errorDecoder != nil {
					err = cli.errorDecoder(rpcResponse.Error.Raw())
				} else {
					err = fmt.Errorf(rpcResponse.Error.Message)
				}
			}
			callback(cli.proceedResponse(ctx, err, cacheKey, fallbackCheck, rpcResponse, &response))
		}
	}
	return
}
